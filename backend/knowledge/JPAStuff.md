## Offloading `id` population to postgres database
In entity:
```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
@Column(name = "id", nullable = false)
private Long id;
```

corresponding to:
```sql
id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
```
in sql table creation

- With GenerationType.IDENTITY, the database is responsible for assigning the primary key value—Hibernate will:
- Issue an INSERT without an id column (letting Postgres’s SERIAL or IDENTITY column fill it in).
- Use JDBC’s getGeneratedKeys() (or PostgreSQL’s RETURNING id) to fetch the newly-created id from the database.
- Populate your entity’s id field after the insert completes.

## Offloading timestamp population (eg. `created_at`, `updated_at`) to the postgres database itself, instead of letting JPA/Hibernate populate them at the application code layer

```java
@ColumnDefault("now()")
@Column(name = "created_at", nullable = false, insertable = false,updatable = false)
private OffsetDateTime createdAt;

@ColumnDefault("now()")
@Column(name = "updated_at", nullable = false, insertable = false)
private OffsetDateTime updatedAt;
```

- By marking the column as insertable = false (and updatable = false), you tell Hibernate not to include that property in its INSERT (or UPDATE) statements. Here’s why that fixes the “not-null property references a null value” error:
- insertable = false lets the database fill in the creation timestamp via its DEFAULT now() clause without Hibernate overwriting it with NULL.
- updatable = false ensure###s that after the row is created, neither Hibernate nor your application code will ever try to change that original timestamp.
- Combined with a DDL default (DEFAULT now() in your table definition), this makes the database the single source of truth for created_at.